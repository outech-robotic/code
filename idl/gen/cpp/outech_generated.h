// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_OUTECH_IDL_GEN_PYTHON_H_
#define FLATBUFFERS_GENERATED_OUTECH_IDL_GEN_PYTHON_H_

#include "flatbuffers/flatbuffers.h"

namespace idl {
namespace gen {
namespace python {

struct HeartbeatMsg;
struct HeartbeatMsgBuilder;

struct StopMovingMsg;
struct StopMovingMsgBuilder;

struct MovementEndedMsg;
struct MovementEndedMsgBuilder;

struct EncoderPositionMsg;
struct EncoderPositionMsgBuilder;

struct PIDCoefficients;

struct PIDConfigMsg;
struct PIDConfigMsgBuilder;

struct WheelControlModeMsg;
struct WheelControlModeMsgBuilder;

struct WheelTolerancesMsg;
struct WheelTolerancesMsgBuilder;

struct MoveWheelAtSpeedMsg;
struct MoveWheelAtSpeedMsgBuilder;

struct WheelPositionTargetMsg;
struct WheelPositionTargetMsgBuilder;

struct WheelPWMMsg;
struct WheelPWMMsgBuilder;

struct TranslateMsg;
struct TranslateMsgBuilder;

struct RotateMsg;
struct RotateMsgBuilder;

struct ServoMsg;
struct ServoMsgBuilder;

struct PumpAndValveMsg;
struct PumpAndValveMsgBuilder;

struct LaserSensorMsg;
struct LaserSensorMsgBuilder;

struct PressureSensorMsg;
struct PressureSensorMsgBuilder;

struct DebugLog;
struct DebugLogBuilder;

struct BusMessage;
struct BusMessageBuilder;

enum BusMessageUnion {
  BusMessageUnion_NONE = 0,
  BusMessageUnion_heartbeat = 1,
  BusMessageUnion_stopMoving = 2,
  BusMessageUnion_movementEnded = 3,
  BusMessageUnion_encoderPosition = 4,
  BusMessageUnion_pidConfig = 5,
  BusMessageUnion_wheelControlMode = 6,
  BusMessageUnion_wheelPositionTarget = 7,
  BusMessageUnion_moveWheelAtSpeed = 8,
  BusMessageUnion_translate = 9,
  BusMessageUnion_rotate = 10,
  BusMessageUnion_servo = 11,
  BusMessageUnion_pumpAndValve = 12,
  BusMessageUnion_laserSensor = 13,
  BusMessageUnion_pressureSensor = 14,
  BusMessageUnion_debugLog = 15,
  BusMessageUnion_wheelTolerances = 16,
  BusMessageUnion_wheelPWM = 17,
  BusMessageUnion_MIN = BusMessageUnion_NONE,
  BusMessageUnion_MAX = BusMessageUnion_wheelPWM
};

inline const BusMessageUnion (&EnumValuesBusMessageUnion())[18] {
  static const BusMessageUnion values[] = {
    BusMessageUnion_NONE,
    BusMessageUnion_heartbeat,
    BusMessageUnion_stopMoving,
    BusMessageUnion_movementEnded,
    BusMessageUnion_encoderPosition,
    BusMessageUnion_pidConfig,
    BusMessageUnion_wheelControlMode,
    BusMessageUnion_wheelPositionTarget,
    BusMessageUnion_moveWheelAtSpeed,
    BusMessageUnion_translate,
    BusMessageUnion_rotate,
    BusMessageUnion_servo,
    BusMessageUnion_pumpAndValve,
    BusMessageUnion_laserSensor,
    BusMessageUnion_pressureSensor,
    BusMessageUnion_debugLog,
    BusMessageUnion_wheelTolerances,
    BusMessageUnion_wheelPWM
  };
  return values;
}

inline const char * const *EnumNamesBusMessageUnion() {
  static const char * const names[19] = {
    "NONE",
    "heartbeat",
    "stopMoving",
    "movementEnded",
    "encoderPosition",
    "pidConfig",
    "wheelControlMode",
    "wheelPositionTarget",
    "moveWheelAtSpeed",
    "translate",
    "rotate",
    "servo",
    "pumpAndValve",
    "laserSensor",
    "pressureSensor",
    "debugLog",
    "wheelTolerances",
    "wheelPWM",
    nullptr
  };
  return names;
}

inline const char *EnumNameBusMessageUnion(BusMessageUnion e) {
  if (flatbuffers::IsOutRange(e, BusMessageUnion_NONE, BusMessageUnion_wheelPWM)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBusMessageUnion()[index];
}

template<typename T> struct BusMessageUnionTraits {
  static const BusMessageUnion enum_value = BusMessageUnion_NONE;
};

template<> struct BusMessageUnionTraits<idl::gen::python::HeartbeatMsg> {
  static const BusMessageUnion enum_value = BusMessageUnion_heartbeat;
};

template<> struct BusMessageUnionTraits<idl::gen::python::StopMovingMsg> {
  static const BusMessageUnion enum_value = BusMessageUnion_stopMoving;
};

template<> struct BusMessageUnionTraits<idl::gen::python::MovementEndedMsg> {
  static const BusMessageUnion enum_value = BusMessageUnion_movementEnded;
};

template<> struct BusMessageUnionTraits<idl::gen::python::EncoderPositionMsg> {
  static const BusMessageUnion enum_value = BusMessageUnion_encoderPosition;
};

template<> struct BusMessageUnionTraits<idl::gen::python::PIDConfigMsg> {
  static const BusMessageUnion enum_value = BusMessageUnion_pidConfig;
};

template<> struct BusMessageUnionTraits<idl::gen::python::WheelControlModeMsg> {
  static const BusMessageUnion enum_value = BusMessageUnion_wheelControlMode;
};

template<> struct BusMessageUnionTraits<idl::gen::python::WheelPositionTargetMsg> {
  static const BusMessageUnion enum_value = BusMessageUnion_wheelPositionTarget;
};

template<> struct BusMessageUnionTraits<idl::gen::python::MoveWheelAtSpeedMsg> {
  static const BusMessageUnion enum_value = BusMessageUnion_moveWheelAtSpeed;
};

template<> struct BusMessageUnionTraits<idl::gen::python::TranslateMsg> {
  static const BusMessageUnion enum_value = BusMessageUnion_translate;
};

template<> struct BusMessageUnionTraits<idl::gen::python::RotateMsg> {
  static const BusMessageUnion enum_value = BusMessageUnion_rotate;
};

template<> struct BusMessageUnionTraits<idl::gen::python::ServoMsg> {
  static const BusMessageUnion enum_value = BusMessageUnion_servo;
};

template<> struct BusMessageUnionTraits<idl::gen::python::PumpAndValveMsg> {
  static const BusMessageUnion enum_value = BusMessageUnion_pumpAndValve;
};

template<> struct BusMessageUnionTraits<idl::gen::python::LaserSensorMsg> {
  static const BusMessageUnion enum_value = BusMessageUnion_laserSensor;
};

template<> struct BusMessageUnionTraits<idl::gen::python::PressureSensorMsg> {
  static const BusMessageUnion enum_value = BusMessageUnion_pressureSensor;
};

template<> struct BusMessageUnionTraits<idl::gen::python::DebugLog> {
  static const BusMessageUnion enum_value = BusMessageUnion_debugLog;
};

template<> struct BusMessageUnionTraits<idl::gen::python::WheelTolerancesMsg> {
  static const BusMessageUnion enum_value = BusMessageUnion_wheelTolerances;
};

template<> struct BusMessageUnionTraits<idl::gen::python::WheelPWMMsg> {
  static const BusMessageUnion enum_value = BusMessageUnion_wheelPWM;
};

bool VerifyBusMessageUnion(flatbuffers::Verifier &verifier, const void *obj, BusMessageUnion type);
bool VerifyBusMessageUnionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) PIDCoefficients FLATBUFFERS_FINAL_CLASS {
 private:
  float kp_;
  float ki_;
  float kd_;

 public:
  PIDCoefficients() {
    memset(static_cast<void *>(this), 0, sizeof(PIDCoefficients));
  }
  PIDCoefficients(float _kp, float _ki, float _kd)
      : kp_(flatbuffers::EndianScalar(_kp)),
        ki_(flatbuffers::EndianScalar(_ki)),
        kd_(flatbuffers::EndianScalar(_kd)) {
  }
  float kp() const {
    return flatbuffers::EndianScalar(kp_);
  }
  float ki() const {
    return flatbuffers::EndianScalar(ki_);
  }
  float kd() const {
    return flatbuffers::EndianScalar(kd_);
  }
};
FLATBUFFERS_STRUCT_END(PIDCoefficients, 12);

struct HeartbeatMsg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HeartbeatMsgBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct HeartbeatMsgBuilder {
  typedef HeartbeatMsg Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit HeartbeatMsgBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HeartbeatMsgBuilder &operator=(const HeartbeatMsgBuilder &);
  flatbuffers::Offset<HeartbeatMsg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HeartbeatMsg>(end);
    return o;
  }
};

inline flatbuffers::Offset<HeartbeatMsg> CreateHeartbeatMsg(
    flatbuffers::FlatBufferBuilder &_fbb) {
  HeartbeatMsgBuilder builder_(_fbb);
  return builder_.Finish();
}

struct StopMovingMsg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StopMovingMsgBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct StopMovingMsgBuilder {
  typedef StopMovingMsg Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit StopMovingMsgBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StopMovingMsgBuilder &operator=(const StopMovingMsgBuilder &);
  flatbuffers::Offset<StopMovingMsg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StopMovingMsg>(end);
    return o;
  }
};

inline flatbuffers::Offset<StopMovingMsg> CreateStopMovingMsg(
    flatbuffers::FlatBufferBuilder &_fbb) {
  StopMovingMsgBuilder builder_(_fbb);
  return builder_.Finish();
}

struct MovementEndedMsg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MovementEndedMsgBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BLOCKED = 4
  };
  bool blocked() const {
    return GetField<uint8_t>(VT_BLOCKED, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_BLOCKED) &&
           verifier.EndTable();
  }
};

struct MovementEndedMsgBuilder {
  typedef MovementEndedMsg Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_blocked(bool blocked) {
    fbb_.AddElement<uint8_t>(MovementEndedMsg::VT_BLOCKED, static_cast<uint8_t>(blocked), 0);
  }
  explicit MovementEndedMsgBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MovementEndedMsgBuilder &operator=(const MovementEndedMsgBuilder &);
  flatbuffers::Offset<MovementEndedMsg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MovementEndedMsg>(end);
    return o;
  }
};

inline flatbuffers::Offset<MovementEndedMsg> CreateMovementEndedMsg(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool blocked = false) {
  MovementEndedMsgBuilder builder_(_fbb);
  builder_.add_blocked(blocked);
  return builder_.Finish();
}

struct EncoderPositionMsg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EncoderPositionMsgBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LEFT_TICK = 4,
    VT_RIGHT_TICK = 6
  };
  int32_t left_tick() const {
    return GetField<int32_t>(VT_LEFT_TICK, 0);
  }
  int32_t right_tick() const {
    return GetField<int32_t>(VT_RIGHT_TICK, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_LEFT_TICK) &&
           VerifyField<int32_t>(verifier, VT_RIGHT_TICK) &&
           verifier.EndTable();
  }
};

struct EncoderPositionMsgBuilder {
  typedef EncoderPositionMsg Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_left_tick(int32_t left_tick) {
    fbb_.AddElement<int32_t>(EncoderPositionMsg::VT_LEFT_TICK, left_tick, 0);
  }
  void add_right_tick(int32_t right_tick) {
    fbb_.AddElement<int32_t>(EncoderPositionMsg::VT_RIGHT_TICK, right_tick, 0);
  }
  explicit EncoderPositionMsgBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EncoderPositionMsgBuilder &operator=(const EncoderPositionMsgBuilder &);
  flatbuffers::Offset<EncoderPositionMsg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EncoderPositionMsg>(end);
    return o;
  }
};

inline flatbuffers::Offset<EncoderPositionMsg> CreateEncoderPositionMsg(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t left_tick = 0,
    int32_t right_tick = 0) {
  EncoderPositionMsgBuilder builder_(_fbb);
  builder_.add_right_tick(right_tick);
  builder_.add_left_tick(left_tick);
  return builder_.Finish();
}

struct PIDConfigMsg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PIDConfigMsgBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PID_SPEED_LEFT = 4,
    VT_PID_SPEED_RIGHT = 6,
    VT_PID_POSITION_LEFT = 8,
    VT_PID_POSITION_RIGHT = 10
  };
  const idl::gen::python::PIDCoefficients *pid_speed_left() const {
    return GetStruct<const idl::gen::python::PIDCoefficients *>(VT_PID_SPEED_LEFT);
  }
  const idl::gen::python::PIDCoefficients *pid_speed_right() const {
    return GetStruct<const idl::gen::python::PIDCoefficients *>(VT_PID_SPEED_RIGHT);
  }
  const idl::gen::python::PIDCoefficients *pid_position_left() const {
    return GetStruct<const idl::gen::python::PIDCoefficients *>(VT_PID_POSITION_LEFT);
  }
  const idl::gen::python::PIDCoefficients *pid_position_right() const {
    return GetStruct<const idl::gen::python::PIDCoefficients *>(VT_PID_POSITION_RIGHT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<idl::gen::python::PIDCoefficients>(verifier, VT_PID_SPEED_LEFT) &&
           VerifyFieldRequired<idl::gen::python::PIDCoefficients>(verifier, VT_PID_SPEED_RIGHT) &&
           VerifyFieldRequired<idl::gen::python::PIDCoefficients>(verifier, VT_PID_POSITION_LEFT) &&
           VerifyFieldRequired<idl::gen::python::PIDCoefficients>(verifier, VT_PID_POSITION_RIGHT) &&
           verifier.EndTable();
  }
};

struct PIDConfigMsgBuilder {
  typedef PIDConfigMsg Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pid_speed_left(const idl::gen::python::PIDCoefficients *pid_speed_left) {
    fbb_.AddStruct(PIDConfigMsg::VT_PID_SPEED_LEFT, pid_speed_left);
  }
  void add_pid_speed_right(const idl::gen::python::PIDCoefficients *pid_speed_right) {
    fbb_.AddStruct(PIDConfigMsg::VT_PID_SPEED_RIGHT, pid_speed_right);
  }
  void add_pid_position_left(const idl::gen::python::PIDCoefficients *pid_position_left) {
    fbb_.AddStruct(PIDConfigMsg::VT_PID_POSITION_LEFT, pid_position_left);
  }
  void add_pid_position_right(const idl::gen::python::PIDCoefficients *pid_position_right) {
    fbb_.AddStruct(PIDConfigMsg::VT_PID_POSITION_RIGHT, pid_position_right);
  }
  explicit PIDConfigMsgBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PIDConfigMsgBuilder &operator=(const PIDConfigMsgBuilder &);
  flatbuffers::Offset<PIDConfigMsg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PIDConfigMsg>(end);
    fbb_.Required(o, PIDConfigMsg::VT_PID_SPEED_LEFT);
    fbb_.Required(o, PIDConfigMsg::VT_PID_SPEED_RIGHT);
    fbb_.Required(o, PIDConfigMsg::VT_PID_POSITION_LEFT);
    fbb_.Required(o, PIDConfigMsg::VT_PID_POSITION_RIGHT);
    return o;
  }
};

inline flatbuffers::Offset<PIDConfigMsg> CreatePIDConfigMsg(
    flatbuffers::FlatBufferBuilder &_fbb,
    const idl::gen::python::PIDCoefficients *pid_speed_left = 0,
    const idl::gen::python::PIDCoefficients *pid_speed_right = 0,
    const idl::gen::python::PIDCoefficients *pid_position_left = 0,
    const idl::gen::python::PIDCoefficients *pid_position_right = 0) {
  PIDConfigMsgBuilder builder_(_fbb);
  builder_.add_pid_position_right(pid_position_right);
  builder_.add_pid_position_left(pid_position_left);
  builder_.add_pid_speed_right(pid_speed_right);
  builder_.add_pid_speed_left(pid_speed_left);
  return builder_.Finish();
}

struct WheelControlModeMsg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WheelControlModeMsgBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SPEED = 4,
    VT_POSITION = 6
  };
  bool speed() const {
    return GetField<uint8_t>(VT_SPEED, 0) != 0;
  }
  bool position() const {
    return GetField<uint8_t>(VT_POSITION, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SPEED) &&
           VerifyField<uint8_t>(verifier, VT_POSITION) &&
           verifier.EndTable();
  }
};

struct WheelControlModeMsgBuilder {
  typedef WheelControlModeMsg Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_speed(bool speed) {
    fbb_.AddElement<uint8_t>(WheelControlModeMsg::VT_SPEED, static_cast<uint8_t>(speed), 0);
  }
  void add_position(bool position) {
    fbb_.AddElement<uint8_t>(WheelControlModeMsg::VT_POSITION, static_cast<uint8_t>(position), 0);
  }
  explicit WheelControlModeMsgBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WheelControlModeMsgBuilder &operator=(const WheelControlModeMsgBuilder &);
  flatbuffers::Offset<WheelControlModeMsg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WheelControlModeMsg>(end);
    return o;
  }
};

inline flatbuffers::Offset<WheelControlModeMsg> CreateWheelControlModeMsg(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool speed = false,
    bool position = false) {
  WheelControlModeMsgBuilder builder_(_fbb);
  builder_.add_position(position);
  builder_.add_speed(speed);
  return builder_.Finish();
}

struct WheelTolerancesMsg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WheelTolerancesMsgBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TICKS_LEFT = 4,
    VT_TICKS_RIGHT = 6
  };
  uint32_t ticks_left() const {
    return GetField<uint32_t>(VT_TICKS_LEFT, 0);
  }
  uint32_t ticks_right() const {
    return GetField<uint32_t>(VT_TICKS_RIGHT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_TICKS_LEFT) &&
           VerifyField<uint32_t>(verifier, VT_TICKS_RIGHT) &&
           verifier.EndTable();
  }
};

struct WheelTolerancesMsgBuilder {
  typedef WheelTolerancesMsg Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ticks_left(uint32_t ticks_left) {
    fbb_.AddElement<uint32_t>(WheelTolerancesMsg::VT_TICKS_LEFT, ticks_left, 0);
  }
  void add_ticks_right(uint32_t ticks_right) {
    fbb_.AddElement<uint32_t>(WheelTolerancesMsg::VT_TICKS_RIGHT, ticks_right, 0);
  }
  explicit WheelTolerancesMsgBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WheelTolerancesMsgBuilder &operator=(const WheelTolerancesMsgBuilder &);
  flatbuffers::Offset<WheelTolerancesMsg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WheelTolerancesMsg>(end);
    return o;
  }
};

inline flatbuffers::Offset<WheelTolerancesMsg> CreateWheelTolerancesMsg(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t ticks_left = 0,
    uint32_t ticks_right = 0) {
  WheelTolerancesMsgBuilder builder_(_fbb);
  builder_.add_ticks_right(ticks_right);
  builder_.add_ticks_left(ticks_left);
  return builder_.Finish();
}

struct MoveWheelAtSpeedMsg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MoveWheelAtSpeedMsgBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LEFT_TICK_PER_SEC = 4,
    VT_RIGHT_TICK_PER_SEC = 6
  };
  int32_t left_tick_per_sec() const {
    return GetField<int32_t>(VT_LEFT_TICK_PER_SEC, 0);
  }
  int32_t right_tick_per_sec() const {
    return GetField<int32_t>(VT_RIGHT_TICK_PER_SEC, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_LEFT_TICK_PER_SEC) &&
           VerifyField<int32_t>(verifier, VT_RIGHT_TICK_PER_SEC) &&
           verifier.EndTable();
  }
};

struct MoveWheelAtSpeedMsgBuilder {
  typedef MoveWheelAtSpeedMsg Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_left_tick_per_sec(int32_t left_tick_per_sec) {
    fbb_.AddElement<int32_t>(MoveWheelAtSpeedMsg::VT_LEFT_TICK_PER_SEC, left_tick_per_sec, 0);
  }
  void add_right_tick_per_sec(int32_t right_tick_per_sec) {
    fbb_.AddElement<int32_t>(MoveWheelAtSpeedMsg::VT_RIGHT_TICK_PER_SEC, right_tick_per_sec, 0);
  }
  explicit MoveWheelAtSpeedMsgBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MoveWheelAtSpeedMsgBuilder &operator=(const MoveWheelAtSpeedMsgBuilder &);
  flatbuffers::Offset<MoveWheelAtSpeedMsg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MoveWheelAtSpeedMsg>(end);
    return o;
  }
};

inline flatbuffers::Offset<MoveWheelAtSpeedMsg> CreateMoveWheelAtSpeedMsg(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t left_tick_per_sec = 0,
    int32_t right_tick_per_sec = 0) {
  MoveWheelAtSpeedMsgBuilder builder_(_fbb);
  builder_.add_right_tick_per_sec(right_tick_per_sec);
  builder_.add_left_tick_per_sec(left_tick_per_sec);
  return builder_.Finish();
}

struct WheelPositionTargetMsg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WheelPositionTargetMsgBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TICK_LEFT = 4,
    VT_TICK_RIGHT = 6
  };
  int32_t tick_left() const {
    return GetField<int32_t>(VT_TICK_LEFT, 0);
  }
  int32_t tick_right() const {
    return GetField<int32_t>(VT_TICK_RIGHT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TICK_LEFT) &&
           VerifyField<int32_t>(verifier, VT_TICK_RIGHT) &&
           verifier.EndTable();
  }
};

struct WheelPositionTargetMsgBuilder {
  typedef WheelPositionTargetMsg Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_tick_left(int32_t tick_left) {
    fbb_.AddElement<int32_t>(WheelPositionTargetMsg::VT_TICK_LEFT, tick_left, 0);
  }
  void add_tick_right(int32_t tick_right) {
    fbb_.AddElement<int32_t>(WheelPositionTargetMsg::VT_TICK_RIGHT, tick_right, 0);
  }
  explicit WheelPositionTargetMsgBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WheelPositionTargetMsgBuilder &operator=(const WheelPositionTargetMsgBuilder &);
  flatbuffers::Offset<WheelPositionTargetMsg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WheelPositionTargetMsg>(end);
    return o;
  }
};

inline flatbuffers::Offset<WheelPositionTargetMsg> CreateWheelPositionTargetMsg(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t tick_left = 0,
    int32_t tick_right = 0) {
  WheelPositionTargetMsgBuilder builder_(_fbb);
  builder_.add_tick_right(tick_right);
  builder_.add_tick_left(tick_left);
  return builder_.Finish();
}

struct WheelPWMMsg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WheelPWMMsgBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RATIO_LEFT = 4,
    VT_RATIO_RIGHT = 6
  };
  float ratio_left() const {
    return GetField<float>(VT_RATIO_LEFT, 0.0f);
  }
  float ratio_right() const {
    return GetField<float>(VT_RATIO_RIGHT, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_RATIO_LEFT) &&
           VerifyField<float>(verifier, VT_RATIO_RIGHT) &&
           verifier.EndTable();
  }
};

struct WheelPWMMsgBuilder {
  typedef WheelPWMMsg Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ratio_left(float ratio_left) {
    fbb_.AddElement<float>(WheelPWMMsg::VT_RATIO_LEFT, ratio_left, 0.0f);
  }
  void add_ratio_right(float ratio_right) {
    fbb_.AddElement<float>(WheelPWMMsg::VT_RATIO_RIGHT, ratio_right, 0.0f);
  }
  explicit WheelPWMMsgBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WheelPWMMsgBuilder &operator=(const WheelPWMMsgBuilder &);
  flatbuffers::Offset<WheelPWMMsg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WheelPWMMsg>(end);
    return o;
  }
};

inline flatbuffers::Offset<WheelPWMMsg> CreateWheelPWMMsg(
    flatbuffers::FlatBufferBuilder &_fbb,
    float ratio_left = 0.0f,
    float ratio_right = 0.0f) {
  WheelPWMMsgBuilder builder_(_fbb);
  builder_.add_ratio_right(ratio_right);
  builder_.add_ratio_left(ratio_left);
  return builder_.Finish();
}

struct TranslateMsg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TranslateMsgBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TICKS = 4
  };
  int32_t ticks() const {
    return GetField<int32_t>(VT_TICKS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TICKS) &&
           verifier.EndTable();
  }
};

struct TranslateMsgBuilder {
  typedef TranslateMsg Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ticks(int32_t ticks) {
    fbb_.AddElement<int32_t>(TranslateMsg::VT_TICKS, ticks, 0);
  }
  explicit TranslateMsgBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TranslateMsgBuilder &operator=(const TranslateMsgBuilder &);
  flatbuffers::Offset<TranslateMsg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TranslateMsg>(end);
    return o;
  }
};

inline flatbuffers::Offset<TranslateMsg> CreateTranslateMsg(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ticks = 0) {
  TranslateMsgBuilder builder_(_fbb);
  builder_.add_ticks(ticks);
  return builder_.Finish();
}

struct RotateMsg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RotateMsgBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TICKS = 4
  };
  int32_t ticks() const {
    return GetField<int32_t>(VT_TICKS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TICKS) &&
           verifier.EndTable();
  }
};

struct RotateMsgBuilder {
  typedef RotateMsg Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ticks(int32_t ticks) {
    fbb_.AddElement<int32_t>(RotateMsg::VT_TICKS, ticks, 0);
  }
  explicit RotateMsgBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RotateMsgBuilder &operator=(const RotateMsgBuilder &);
  flatbuffers::Offset<RotateMsg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RotateMsg>(end);
    return o;
  }
};

inline flatbuffers::Offset<RotateMsg> CreateRotateMsg(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ticks = 0) {
  RotateMsgBuilder builder_(_fbb);
  builder_.add_ticks(ticks);
  return builder_.Finish();
}

struct ServoMsg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ServoMsgBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_ANGLE = 6
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  int32_t angle() const {
    return GetField<int32_t>(VT_ANGLE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID) &&
           VerifyField<int32_t>(verifier, VT_ANGLE) &&
           verifier.EndTable();
  }
};

struct ServoMsgBuilder {
  typedef ServoMsg Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(ServoMsg::VT_ID, id, 0);
  }
  void add_angle(int32_t angle) {
    fbb_.AddElement<int32_t>(ServoMsg::VT_ANGLE, angle, 0);
  }
  explicit ServoMsgBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ServoMsgBuilder &operator=(const ServoMsgBuilder &);
  flatbuffers::Offset<ServoMsg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ServoMsg>(end);
    return o;
  }
};

inline flatbuffers::Offset<ServoMsg> CreateServoMsg(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    int32_t angle = 0) {
  ServoMsgBuilder builder_(_fbb);
  builder_.add_angle(angle);
  builder_.add_id(id);
  return builder_.Finish();
}

struct PumpAndValveMsg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PumpAndValveMsgBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_ON = 6
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  bool on() const {
    return GetField<uint8_t>(VT_ON, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID) &&
           VerifyField<uint8_t>(verifier, VT_ON) &&
           verifier.EndTable();
  }
};

struct PumpAndValveMsgBuilder {
  typedef PumpAndValveMsg Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(PumpAndValveMsg::VT_ID, id, 0);
  }
  void add_on(bool on) {
    fbb_.AddElement<uint8_t>(PumpAndValveMsg::VT_ON, static_cast<uint8_t>(on), 0);
  }
  explicit PumpAndValveMsgBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PumpAndValveMsgBuilder &operator=(const PumpAndValveMsgBuilder &);
  flatbuffers::Offset<PumpAndValveMsg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PumpAndValveMsg>(end);
    return o;
  }
};

inline flatbuffers::Offset<PumpAndValveMsg> CreatePumpAndValveMsg(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    bool on = false) {
  PumpAndValveMsgBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_on(on);
  return builder_.Finish();
}

struct LaserSensorMsg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LaserSensorMsgBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DISTANCE_FRONT_LEFT = 4,
    VT_DISTANCE_FRONT_RIGHT = 6,
    VT_DISTANCE_BACK_LEFT = 8,
    VT_DISTANCE_BACK_RIGHT = 10
  };
  uint32_t distance_front_left() const {
    return GetField<uint32_t>(VT_DISTANCE_FRONT_LEFT, 0);
  }
  uint32_t distance_front_right() const {
    return GetField<uint32_t>(VT_DISTANCE_FRONT_RIGHT, 0);
  }
  uint32_t distance_back_left() const {
    return GetField<uint32_t>(VT_DISTANCE_BACK_LEFT, 0);
  }
  uint32_t distance_back_right() const {
    return GetField<uint32_t>(VT_DISTANCE_BACK_RIGHT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_DISTANCE_FRONT_LEFT) &&
           VerifyField<uint32_t>(verifier, VT_DISTANCE_FRONT_RIGHT) &&
           VerifyField<uint32_t>(verifier, VT_DISTANCE_BACK_LEFT) &&
           VerifyField<uint32_t>(verifier, VT_DISTANCE_BACK_RIGHT) &&
           verifier.EndTable();
  }
};

struct LaserSensorMsgBuilder {
  typedef LaserSensorMsg Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_distance_front_left(uint32_t distance_front_left) {
    fbb_.AddElement<uint32_t>(LaserSensorMsg::VT_DISTANCE_FRONT_LEFT, distance_front_left, 0);
  }
  void add_distance_front_right(uint32_t distance_front_right) {
    fbb_.AddElement<uint32_t>(LaserSensorMsg::VT_DISTANCE_FRONT_RIGHT, distance_front_right, 0);
  }
  void add_distance_back_left(uint32_t distance_back_left) {
    fbb_.AddElement<uint32_t>(LaserSensorMsg::VT_DISTANCE_BACK_LEFT, distance_back_left, 0);
  }
  void add_distance_back_right(uint32_t distance_back_right) {
    fbb_.AddElement<uint32_t>(LaserSensorMsg::VT_DISTANCE_BACK_RIGHT, distance_back_right, 0);
  }
  explicit LaserSensorMsgBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LaserSensorMsgBuilder &operator=(const LaserSensorMsgBuilder &);
  flatbuffers::Offset<LaserSensorMsg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LaserSensorMsg>(end);
    return o;
  }
};

inline flatbuffers::Offset<LaserSensorMsg> CreateLaserSensorMsg(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t distance_front_left = 0,
    uint32_t distance_front_right = 0,
    uint32_t distance_back_left = 0,
    uint32_t distance_back_right = 0) {
  LaserSensorMsgBuilder builder_(_fbb);
  builder_.add_distance_back_right(distance_back_right);
  builder_.add_distance_back_left(distance_back_left);
  builder_.add_distance_front_right(distance_front_right);
  builder_.add_distance_front_left(distance_front_left);
  return builder_.Finish();
}

struct PressureSensorMsg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PressureSensorMsgBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ON_LEFT = 4,
    VT_ON_CENTER_LEFT = 6,
    VT_ON_CENTER = 8,
    VT_ON_CENTER_RIGHT = 10,
    VT_ON_RIGHT = 12
  };
  bool on_left() const {
    return GetField<uint8_t>(VT_ON_LEFT, 0) != 0;
  }
  bool on_center_left() const {
    return GetField<uint8_t>(VT_ON_CENTER_LEFT, 0) != 0;
  }
  bool on_center() const {
    return GetField<uint8_t>(VT_ON_CENTER, 0) != 0;
  }
  bool on_center_right() const {
    return GetField<uint8_t>(VT_ON_CENTER_RIGHT, 0) != 0;
  }
  bool on_right() const {
    return GetField<uint8_t>(VT_ON_RIGHT, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ON_LEFT) &&
           VerifyField<uint8_t>(verifier, VT_ON_CENTER_LEFT) &&
           VerifyField<uint8_t>(verifier, VT_ON_CENTER) &&
           VerifyField<uint8_t>(verifier, VT_ON_CENTER_RIGHT) &&
           VerifyField<uint8_t>(verifier, VT_ON_RIGHT) &&
           verifier.EndTable();
  }
};

struct PressureSensorMsgBuilder {
  typedef PressureSensorMsg Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_on_left(bool on_left) {
    fbb_.AddElement<uint8_t>(PressureSensorMsg::VT_ON_LEFT, static_cast<uint8_t>(on_left), 0);
  }
  void add_on_center_left(bool on_center_left) {
    fbb_.AddElement<uint8_t>(PressureSensorMsg::VT_ON_CENTER_LEFT, static_cast<uint8_t>(on_center_left), 0);
  }
  void add_on_center(bool on_center) {
    fbb_.AddElement<uint8_t>(PressureSensorMsg::VT_ON_CENTER, static_cast<uint8_t>(on_center), 0);
  }
  void add_on_center_right(bool on_center_right) {
    fbb_.AddElement<uint8_t>(PressureSensorMsg::VT_ON_CENTER_RIGHT, static_cast<uint8_t>(on_center_right), 0);
  }
  void add_on_right(bool on_right) {
    fbb_.AddElement<uint8_t>(PressureSensorMsg::VT_ON_RIGHT, static_cast<uint8_t>(on_right), 0);
  }
  explicit PressureSensorMsgBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PressureSensorMsgBuilder &operator=(const PressureSensorMsgBuilder &);
  flatbuffers::Offset<PressureSensorMsg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PressureSensorMsg>(end);
    return o;
  }
};

inline flatbuffers::Offset<PressureSensorMsg> CreatePressureSensorMsg(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool on_left = false,
    bool on_center_left = false,
    bool on_center = false,
    bool on_center_right = false,
    bool on_right = false) {
  PressureSensorMsgBuilder builder_(_fbb);
  builder_.add_on_right(on_right);
  builder_.add_on_center_right(on_center_right);
  builder_.add_on_center(on_center);
  builder_.add_on_center_left(on_center_left);
  builder_.add_on_left(on_left);
  return builder_.Finish();
}

struct DebugLog FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DebugLogBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONTENT = 4
  };
  const flatbuffers::String *content() const {
    return GetPointer<const flatbuffers::String *>(VT_CONTENT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_CONTENT) &&
           verifier.VerifyString(content()) &&
           verifier.EndTable();
  }
};

struct DebugLogBuilder {
  typedef DebugLog Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_content(flatbuffers::Offset<flatbuffers::String> content) {
    fbb_.AddOffset(DebugLog::VT_CONTENT, content);
  }
  explicit DebugLogBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DebugLogBuilder &operator=(const DebugLogBuilder &);
  flatbuffers::Offset<DebugLog> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DebugLog>(end);
    fbb_.Required(o, DebugLog::VT_CONTENT);
    return o;
  }
};

inline flatbuffers::Offset<DebugLog> CreateDebugLog(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> content = 0) {
  DebugLogBuilder builder_(_fbb);
  builder_.add_content(content);
  return builder_.Finish();
}

inline flatbuffers::Offset<DebugLog> CreateDebugLogDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *content = nullptr) {
  auto content__ = content ? _fbb.CreateString(content) : 0;
  return idl::gen::python::CreateDebugLog(
      _fbb,
      content__);
}

struct BusMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BusMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONTENT_TYPE = 4,
    VT_CONTENT = 6
  };
  idl::gen::python::BusMessageUnion content_type() const {
    return static_cast<idl::gen::python::BusMessageUnion>(GetField<uint8_t>(VT_CONTENT_TYPE, 0));
  }
  const void *content() const {
    return GetPointer<const void *>(VT_CONTENT);
  }
  template<typename T> const T *content_as() const;
  const idl::gen::python::HeartbeatMsg *content_as_heartbeat() const {
    return content_type() == idl::gen::python::BusMessageUnion_heartbeat ? static_cast<const idl::gen::python::HeartbeatMsg *>(content()) : nullptr;
  }
  const idl::gen::python::StopMovingMsg *content_as_stopMoving() const {
    return content_type() == idl::gen::python::BusMessageUnion_stopMoving ? static_cast<const idl::gen::python::StopMovingMsg *>(content()) : nullptr;
  }
  const idl::gen::python::MovementEndedMsg *content_as_movementEnded() const {
    return content_type() == idl::gen::python::BusMessageUnion_movementEnded ? static_cast<const idl::gen::python::MovementEndedMsg *>(content()) : nullptr;
  }
  const idl::gen::python::EncoderPositionMsg *content_as_encoderPosition() const {
    return content_type() == idl::gen::python::BusMessageUnion_encoderPosition ? static_cast<const idl::gen::python::EncoderPositionMsg *>(content()) : nullptr;
  }
  const idl::gen::python::PIDConfigMsg *content_as_pidConfig() const {
    return content_type() == idl::gen::python::BusMessageUnion_pidConfig ? static_cast<const idl::gen::python::PIDConfigMsg *>(content()) : nullptr;
  }
  const idl::gen::python::WheelControlModeMsg *content_as_wheelControlMode() const {
    return content_type() == idl::gen::python::BusMessageUnion_wheelControlMode ? static_cast<const idl::gen::python::WheelControlModeMsg *>(content()) : nullptr;
  }
  const idl::gen::python::WheelPositionTargetMsg *content_as_wheelPositionTarget() const {
    return content_type() == idl::gen::python::BusMessageUnion_wheelPositionTarget ? static_cast<const idl::gen::python::WheelPositionTargetMsg *>(content()) : nullptr;
  }
  const idl::gen::python::MoveWheelAtSpeedMsg *content_as_moveWheelAtSpeed() const {
    return content_type() == idl::gen::python::BusMessageUnion_moveWheelAtSpeed ? static_cast<const idl::gen::python::MoveWheelAtSpeedMsg *>(content()) : nullptr;
  }
  const idl::gen::python::TranslateMsg *content_as_translate() const {
    return content_type() == idl::gen::python::BusMessageUnion_translate ? static_cast<const idl::gen::python::TranslateMsg *>(content()) : nullptr;
  }
  const idl::gen::python::RotateMsg *content_as_rotate() const {
    return content_type() == idl::gen::python::BusMessageUnion_rotate ? static_cast<const idl::gen::python::RotateMsg *>(content()) : nullptr;
  }
  const idl::gen::python::ServoMsg *content_as_servo() const {
    return content_type() == idl::gen::python::BusMessageUnion_servo ? static_cast<const idl::gen::python::ServoMsg *>(content()) : nullptr;
  }
  const idl::gen::python::PumpAndValveMsg *content_as_pumpAndValve() const {
    return content_type() == idl::gen::python::BusMessageUnion_pumpAndValve ? static_cast<const idl::gen::python::PumpAndValveMsg *>(content()) : nullptr;
  }
  const idl::gen::python::LaserSensorMsg *content_as_laserSensor() const {
    return content_type() == idl::gen::python::BusMessageUnion_laserSensor ? static_cast<const idl::gen::python::LaserSensorMsg *>(content()) : nullptr;
  }
  const idl::gen::python::PressureSensorMsg *content_as_pressureSensor() const {
    return content_type() == idl::gen::python::BusMessageUnion_pressureSensor ? static_cast<const idl::gen::python::PressureSensorMsg *>(content()) : nullptr;
  }
  const idl::gen::python::DebugLog *content_as_debugLog() const {
    return content_type() == idl::gen::python::BusMessageUnion_debugLog ? static_cast<const idl::gen::python::DebugLog *>(content()) : nullptr;
  }
  const idl::gen::python::WheelTolerancesMsg *content_as_wheelTolerances() const {
    return content_type() == idl::gen::python::BusMessageUnion_wheelTolerances ? static_cast<const idl::gen::python::WheelTolerancesMsg *>(content()) : nullptr;
  }
  const idl::gen::python::WheelPWMMsg *content_as_wheelPWM() const {
    return content_type() == idl::gen::python::BusMessageUnion_wheelPWM ? static_cast<const idl::gen::python::WheelPWMMsg *>(content()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_CONTENT_TYPE) &&
           VerifyOffsetRequired(verifier, VT_CONTENT) &&
           VerifyBusMessageUnion(verifier, content(), content_type()) &&
           verifier.EndTable();
  }
};

template<> inline const idl::gen::python::HeartbeatMsg *BusMessage::content_as<idl::gen::python::HeartbeatMsg>() const {
  return content_as_heartbeat();
}

template<> inline const idl::gen::python::StopMovingMsg *BusMessage::content_as<idl::gen::python::StopMovingMsg>() const {
  return content_as_stopMoving();
}

template<> inline const idl::gen::python::MovementEndedMsg *BusMessage::content_as<idl::gen::python::MovementEndedMsg>() const {
  return content_as_movementEnded();
}

template<> inline const idl::gen::python::EncoderPositionMsg *BusMessage::content_as<idl::gen::python::EncoderPositionMsg>() const {
  return content_as_encoderPosition();
}

template<> inline const idl::gen::python::PIDConfigMsg *BusMessage::content_as<idl::gen::python::PIDConfigMsg>() const {
  return content_as_pidConfig();
}

template<> inline const idl::gen::python::WheelControlModeMsg *BusMessage::content_as<idl::gen::python::WheelControlModeMsg>() const {
  return content_as_wheelControlMode();
}

template<> inline const idl::gen::python::WheelPositionTargetMsg *BusMessage::content_as<idl::gen::python::WheelPositionTargetMsg>() const {
  return content_as_wheelPositionTarget();
}

template<> inline const idl::gen::python::MoveWheelAtSpeedMsg *BusMessage::content_as<idl::gen::python::MoveWheelAtSpeedMsg>() const {
  return content_as_moveWheelAtSpeed();
}

template<> inline const idl::gen::python::TranslateMsg *BusMessage::content_as<idl::gen::python::TranslateMsg>() const {
  return content_as_translate();
}

template<> inline const idl::gen::python::RotateMsg *BusMessage::content_as<idl::gen::python::RotateMsg>() const {
  return content_as_rotate();
}

template<> inline const idl::gen::python::ServoMsg *BusMessage::content_as<idl::gen::python::ServoMsg>() const {
  return content_as_servo();
}

template<> inline const idl::gen::python::PumpAndValveMsg *BusMessage::content_as<idl::gen::python::PumpAndValveMsg>() const {
  return content_as_pumpAndValve();
}

template<> inline const idl::gen::python::LaserSensorMsg *BusMessage::content_as<idl::gen::python::LaserSensorMsg>() const {
  return content_as_laserSensor();
}

template<> inline const idl::gen::python::PressureSensorMsg *BusMessage::content_as<idl::gen::python::PressureSensorMsg>() const {
  return content_as_pressureSensor();
}

template<> inline const idl::gen::python::DebugLog *BusMessage::content_as<idl::gen::python::DebugLog>() const {
  return content_as_debugLog();
}

template<> inline const idl::gen::python::WheelTolerancesMsg *BusMessage::content_as<idl::gen::python::WheelTolerancesMsg>() const {
  return content_as_wheelTolerances();
}

template<> inline const idl::gen::python::WheelPWMMsg *BusMessage::content_as<idl::gen::python::WheelPWMMsg>() const {
  return content_as_wheelPWM();
}

struct BusMessageBuilder {
  typedef BusMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_content_type(idl::gen::python::BusMessageUnion content_type) {
    fbb_.AddElement<uint8_t>(BusMessage::VT_CONTENT_TYPE, static_cast<uint8_t>(content_type), 0);
  }
  void add_content(flatbuffers::Offset<void> content) {
    fbb_.AddOffset(BusMessage::VT_CONTENT, content);
  }
  explicit BusMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BusMessageBuilder &operator=(const BusMessageBuilder &);
  flatbuffers::Offset<BusMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BusMessage>(end);
    fbb_.Required(o, BusMessage::VT_CONTENT);
    return o;
  }
};

inline flatbuffers::Offset<BusMessage> CreateBusMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    idl::gen::python::BusMessageUnion content_type = idl::gen::python::BusMessageUnion_NONE,
    flatbuffers::Offset<void> content = 0) {
  BusMessageBuilder builder_(_fbb);
  builder_.add_content(content);
  builder_.add_content_type(content_type);
  return builder_.Finish();
}

inline bool VerifyBusMessageUnion(flatbuffers::Verifier &verifier, const void *obj, BusMessageUnion type) {
  switch (type) {
    case BusMessageUnion_NONE: {
      return true;
    }
    case BusMessageUnion_heartbeat: {
      auto ptr = reinterpret_cast<const idl::gen::python::HeartbeatMsg *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BusMessageUnion_stopMoving: {
      auto ptr = reinterpret_cast<const idl::gen::python::StopMovingMsg *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BusMessageUnion_movementEnded: {
      auto ptr = reinterpret_cast<const idl::gen::python::MovementEndedMsg *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BusMessageUnion_encoderPosition: {
      auto ptr = reinterpret_cast<const idl::gen::python::EncoderPositionMsg *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BusMessageUnion_pidConfig: {
      auto ptr = reinterpret_cast<const idl::gen::python::PIDConfigMsg *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BusMessageUnion_wheelControlMode: {
      auto ptr = reinterpret_cast<const idl::gen::python::WheelControlModeMsg *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BusMessageUnion_wheelPositionTarget: {
      auto ptr = reinterpret_cast<const idl::gen::python::WheelPositionTargetMsg *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BusMessageUnion_moveWheelAtSpeed: {
      auto ptr = reinterpret_cast<const idl::gen::python::MoveWheelAtSpeedMsg *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BusMessageUnion_translate: {
      auto ptr = reinterpret_cast<const idl::gen::python::TranslateMsg *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BusMessageUnion_rotate: {
      auto ptr = reinterpret_cast<const idl::gen::python::RotateMsg *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BusMessageUnion_servo: {
      auto ptr = reinterpret_cast<const idl::gen::python::ServoMsg *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BusMessageUnion_pumpAndValve: {
      auto ptr = reinterpret_cast<const idl::gen::python::PumpAndValveMsg *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BusMessageUnion_laserSensor: {
      auto ptr = reinterpret_cast<const idl::gen::python::LaserSensorMsg *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BusMessageUnion_pressureSensor: {
      auto ptr = reinterpret_cast<const idl::gen::python::PressureSensorMsg *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BusMessageUnion_debugLog: {
      auto ptr = reinterpret_cast<const idl::gen::python::DebugLog *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BusMessageUnion_wheelTolerances: {
      auto ptr = reinterpret_cast<const idl::gen::python::WheelTolerancesMsg *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BusMessageUnion_wheelPWM: {
      auto ptr = reinterpret_cast<const idl::gen::python::WheelPWMMsg *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyBusMessageUnionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyBusMessageUnion(
        verifier,  values->Get(i), types->GetEnum<BusMessageUnion>(i))) {
      return false;
    }
  }
  return true;
}

inline const idl::gen::python::BusMessage *GetBusMessage(const void *buf) {
  return flatbuffers::GetRoot<idl::gen::python::BusMessage>(buf);
}

inline const idl::gen::python::BusMessage *GetSizePrefixedBusMessage(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<idl::gen::python::BusMessage>(buf);
}

inline bool VerifyBusMessageBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<idl::gen::python::BusMessage>(nullptr);
}

inline bool VerifySizePrefixedBusMessageBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<idl::gen::python::BusMessage>(nullptr);
}

inline void FinishBusMessageBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<idl::gen::python::BusMessage> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedBusMessageBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<idl::gen::python::BusMessage> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace python
}  // namespace gen
}  // namespace idl

#endif  // FLATBUFFERS_GENERATED_OUTECH_IDL_GEN_PYTHON_H_
